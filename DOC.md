# Documentation

## Protobuf

Protocol buffers is a very convenient technology to define so called [protobuf](https://protobuf.dev/) contracts,
also known as proto definitions.
It exposes a bunch of code generators for various programming languages, which given the proto definition
are able to generate code that can serialize and deserialize messages according to the contract.

This technology is superior in performance to json and xml encoding, as it utilizes a binary format.

### Buf connect

Protobuf is typically paired with network technologies, such as gRPC, which builds a client-server protocol around the
protobuf messages, allowing to define remote procedures (RPCs) and request/response messages.
Over the years, alternatives to gRPC have been developed, and alternative code generators, such as
[buf](https://buf.build/),

Buf implements several utilities such as linting, breaking change detection, and even a schema registry.
On top of that, it offers an alternative to gRPC, called `buf connect`, which offers several advantages:
- apart from the protobuf serializer, it also supports JSON and YAML, which can be useful when debugging or demoing
- it is able to run on any http version, and not just http2, which is a requirement for gRPC

### Our implementation

We have chosen to use `buf connect` for our sequencer. Proto definitions can be [found here](proto/blockchain/v1).
Interacting with the buf server requires either a client (for which sources are generated by buf), or via tools such
as curl or Postman.

By convention, routing happens via a POST to /{package}.{service}/{method}.
Example: POST /blockchain.v1.SequencerService/Shuffle
When sending the encoding header as `application/json`, it's possible to craft requests for testing.
Note that byte fields have to be represented as base64 strings when using json.

See the main [README](README.md) for an example of a curl request.
